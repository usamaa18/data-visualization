const url = "https://raw.githubusercontent.com/freeCodeCamp/ProjectReferenceData/master/cyclist-data.json";
const xhr = new XMLHttpRequest();
xhr.open("GET", url, true);

const scale = 0.5;
const w = 1920*scale;
const h = 1080*scale;
const margin = {
    top: 20, bottom: 20, left: 40, right: 20
};

xhr.onload = function() {
    const json = JSON.parse(xhr.responseText);
    console.log(json);

    // dont use d3.timeParse(). It's epoch is set to Jan 1 1900,
    // which is causing the y-axis time scale to shift to values that
    // are not a multiple of 5 seconds: 
    // const parseTime = d3.timeParse("%M:%S");
    // as a result, I've also decided to opt-out of timeParse() for parseYear:
    // const parseYear = d3.timeParse("%Y");
    
    // instead use built-in Date() constructor in JS
    const parseTime = seconds => new Date(seconds*1000);
    const parseYear = year => new Date(year, 0, 0, 0, 0, 0, 0);
    
    const years = json.map(obj => parseYear(obj.Year));
    const times = json.map(obj => parseTime(obj.Seconds));

    const xScale = d3.scaleTime()
        .domain([d3.min(years), d3.max(years)])
        .range([margin.left, w - margin.right]);

    const yScale = d3.scaleTime()
        .domain([d3.min(times), d3.max(times)])
        .range([margin.top, h - margin.bottom]);

    const svg = d3.select("#root")
        .append("svg")
        .attr("height", h)
        .attr("width", w);
    
    const xAxis = d3.axisBottom(xScale);
    svg.append("g")
        .attr("id", "x-axis")
        .attr("transform", "translate(0, " + (h - margin.bottom) + ")")
        .call(xAxis);
    
    const yAxis = d3.axisLeft(yScale)
        .ticks(d3.timeSecond.every(15))
        .tickFormat(d => {  
            console.log(d);
            return d3.timeFormat("%M:%S")(d);
        });
    svg.append("g")
        .attr("id", "y-axis")
        .attr("transform", "translate(" + margin.left + ", 0)")
        .call(yAxis);
};
xhr.send();